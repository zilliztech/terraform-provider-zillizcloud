package provider

import (
	"context"
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	zilliz "github.com/zilliztech/terraform-provider-zillizcloud/client"
)

// NewCollectionResource returns a new collection resource.
func NewCollectionResource() resource.Resource {
	return &CollectionResource{}
}

type CollectionResource struct {
	client *zilliz.Client
}

type CollectionResourceModel struct {
	Id             types.String           `tfsdk:"id"` // /connections/{connect_address}/databases/{db_name}/collections/{collection_name}
	ConnectAddress types.String           `tfsdk:"connect_address"`
	DbName         types.String           `tfsdk:"db_name"`
	CollectionName types.String           `tfsdk:"collection_name"`
	Schema         *CollectionSchemaModel `tfsdk:"schema"`
	Params         *CollectionParamsModel `tfsdk:"params"`
}

type CollectionParamsModel struct {
	MMAPEnabled      types.Bool   `tfsdk:"mmap_enabled"`
	TTLSeconds       types.Int64  `tfsdk:"ttl_seconds"`
	ConsistencyLevel types.String `tfsdk:"consistency_level"`
}

type CollectionSchemaModel struct {
	AutoID              types.Bool                   `tfsdk:"auto_id"`
	EnabledDynamicField types.Bool                   `tfsdk:"enabled_dynamic_field"`
	Fields              []CollectionSchemaFieldModel `tfsdk:"fields"`
}

type CollectionSchemaFieldModel struct {
	FieldName         types.String            `tfsdk:"field_name"`
	DataType          types.String            `tfsdk:"data_type"`
	IsPrimary         types.Bool              `tfsdk:"is_primary"`
	ElementTypeParams map[string]types.String `tfsdk:"element_type_params"`
}

var _ resource.ResourceWithImportState = &CollectionResource{}

func (r *CollectionResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_collection"
}

func (r *CollectionResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: `Manages a collection in a Zilliz Cloud database.
The schema block must be defined inline. Changing the schema, db_name, or collection_name will force resource replacement.`,
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				MarkdownDescription: `The unique identifier for the collection resource, generated by the service.

**Format:**
` + "`/connections/{db_name}/collections/{collection_name}`" + `

**Example:**
` + "`/connections/mydb/collections/mycollection`" + `

> **Note:** This value is automatically set and should not be manually specified.`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"connect_address": schema.StringAttribute{
				Required: true,
				MarkdownDescription: `The connection address of the target Zilliz Cloud cluster.
You can obtain this value from the output of the ` + "`zillizcloud_cluster`" + ` resource, for example:
` + "`zillizcloud_cluster.example.connect_address`" + `

**Example:**
` + "`https://in01-295cd02566647b7.aws-us-east-2.vectordb.zillizcloud.com:19534`" + `

> **Note:** The address must include the protocol (e.g., ` + "`https://`" + `).`,
			},
			"db_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `The name of the database containing the collection.`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"collection_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `The name of the collection.`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"params": schema.SingleNestedAttribute{
				Optional: true,
				MarkdownDescription: `A JSON-formatted map of advanced params.

**Example:**

` + "```" + `
params = {
	"mmap_enabled"      = true
	"ttl_seconds"       = 86400
	"consistency_level" = "Bounded"
}
` + "```" + `

> Supports string, integer, and boolean values.`,
				Attributes: map[string]schema.Attribute{
					"mmap_enabled": schema.BoolAttribute{
						Optional:            true,
						MarkdownDescription: `Whether to enable memory-mapped files for the collection.`,
					},
					"ttl_seconds": schema.Int64Attribute{
						Optional:            true,
						MarkdownDescription: `Time-to-live (TTL) in seconds for the collection. After this period, the collection will be automatically deleted.`,
					},
					"consistency_level": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString("Bounded"),
						MarkdownDescription: `The consistency level for the collection. Possible values are (Bounded|Strong|Session|Eventually). Defaults to "Bounded".
Reference: https://github.com/milvus-io/milvus-proto/blob/2.5/go-api/commonpb/common.pb.go#L1001`,
					},
				},
			},
			"schema": schema.SingleNestedAttribute{
				Required: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
				MarkdownDescription: `Defines the schema for the collection. Changing this block will force resource replacement.`,
				Attributes: map[string]schema.Attribute{
					"auto_id": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Default:             booldefault.StaticBool(false),
						MarkdownDescription: `Whether to enable automatic ID generation for the collection.`,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplace(),
						},
					},
					"enabled_dynamic_field": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: `Whether to enable dynamic fields for the collection.`,
						Default:             booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplace(),
						},
					},
					"fields": schema.ListNestedAttribute{
						Required:            true,
						MarkdownDescription: `List of field definitions for the collection schema. Each field describes a column in the collection.`,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplace(),
						},
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"field_name": schema.StringAttribute{
									Required:            true,
									MarkdownDescription: `The name of the field.`,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
								"data_type": schema.StringAttribute{
									Required:            true,
									MarkdownDescription: `The data type of the field (e.g., "INT64", "FLOAT", "STRING", etc.).`,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
								"is_primary": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									MarkdownDescription: `Whether this field is the primary key.`,
									Default:             booldefault.StaticBool(false),
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplace(),
									},
								},
								"element_type_params": schema.MapAttribute{
									Optional:    true,
									Computed:    true,
									ElementType: types.StringType,
									Default: mapdefault.StaticValue(types.MapValueMust(
										types.StringType,
										map[string]attr.Value{},
									)),
									MarkdownDescription: `Additional parameters for element type, if applicable (e.g., for array fields).`,
									PlanModifiers: []planmodifier.Map{
										mapplanmodifier.RequiresReplace(),
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *CollectionResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*zilliz.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected provider type",
			fmt.Sprintf("Expected *zilliz.Client, got: %T. Please check provider configuration.", req.ProviderData),
		)
		return
	}
	r.client = client
}

func convertSchemaFields(fields []CollectionSchemaFieldModel) []zilliz.CollectionSchemaField {
	result := make([]zilliz.CollectionSchemaField, len(fields))
	for i, f := range fields {
		params := map[string]any{}
		for k, v := range f.ElementTypeParams {
			params[k] = v.ValueString()
		}
		result[i] = zilliz.CollectionSchemaField{
			FieldName:         f.FieldName.ValueString(),
			DataType:          f.DataType.ValueString(),
			IsPrimary:         f.IsPrimary.ValueBool(),
			ElementTypeParams: params,
		}
	}
	return result
}
func convertSchemaFieldModel(field zilliz.CollectionField) CollectionSchemaFieldModel {
	elementTypeParams := make(map[string]types.String)
	for _, v := range field.Params {
		elementTypeParams[v.Key] = types.StringValue(v.Value)
	}

	return CollectionSchemaFieldModel{
		FieldName:         types.StringValue(field.Name),
		DataType:          types.StringValue(field.Type),
		IsPrimary:         types.BoolValue(field.PrimaryKey),
		ElementTypeParams: elementTypeParams,
	}
}

func (r *CollectionResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data CollectionResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...) // Get planned data
	if resp.Diagnostics.HasError() {
		return
	}

	connectAddress := data.ConnectAddress.ValueString()
	client, err := r.client.Collection(connectAddress, data.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get cluster client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddress, err.Error()),
		)
		return
	}
	params := make(map[string]any)
	// set default consistency_level
	params["consistencyLevel"] = "Bounded"

	if data.Params != nil {
		if !data.Params.MMAPEnabled.IsNull() && !data.Params.MMAPEnabled.IsUnknown() {
			params["mmap.enabled"] = data.Params.MMAPEnabled.ValueBool()
		}
		if !data.Params.TTLSeconds.IsNull() && !data.Params.TTLSeconds.IsUnknown() {
			params["ttlSeconds"] = data.Params.TTLSeconds.ValueInt64()
		}
		if !data.Params.ConsistencyLevel.IsNull() && !data.Params.ConsistencyLevel.IsUnknown() {
			params["consistencyLevel"] = data.Params.ConsistencyLevel.ValueString()
		}
	}

	err = client.CreateCollection(&zilliz.CreateCollectionParams{
		DbName:         data.DbName.ValueString(),
		CollectionName: data.CollectionName.ValueString(),
		Schema: zilliz.CollectionSchema{
			AutoID:              data.Schema.AutoID.ValueBool(),
			EnabledDynamicField: data.Schema.EnabledDynamicField.ValueBool(),
			Fields:              convertSchemaFields(data.Schema.Fields),
		},
		Params: params,
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to create database",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, error: %s", connectAddress, data.DbName.ValueString(), err.Error()),
		)
		return
	}

	connectAddress = NormalizeConnectionID(connectAddress)

	data.Id = types.StringValue(BuildCollectionID(connectAddress, data.DbName.ValueString(), data.CollectionName.ValueString()))
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...) // Save state
}

func (r *CollectionResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data CollectionResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...) // Get current state
	if resp.Diagnostics.HasError() {
		return
	}

	connectAddress := data.ConnectAddress.ValueString()
	client, err := r.client.Collection(connectAddress, data.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get cluster client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddress, err.Error()),
		)
		return
	}

	desc, err := client.DescribeCollection(&zilliz.DescribeCollectionParams{
		DbName:         data.DbName.ValueString(),
		CollectionName: data.CollectionName.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to describe collection",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s", connectAddress, data.DbName.ValueString(), data.CollectionName.ValueString(), err.Error()),
		)
		return
	}
	fields := make([]CollectionSchemaFieldModel, len(desc.Fields))
	for i, field := range desc.Fields {
		fields[i] = convertSchemaFieldModel(field)
	}
	data.Schema = &CollectionSchemaModel{
		AutoID:              types.BoolValue(desc.AutoID),
		EnabledDynamicField: types.BoolValue(desc.EnableDynamicField),
		Fields:              fields,
	}
	data.CollectionName = types.StringValue(desc.CollectionName)

	// Only set params if it was originally configured by the user
	if data.Params != nil {
		// Initialize with current state values to preserve user configuration
		params := &CollectionParamsModel{
			MMAPEnabled:      data.Params.MMAPEnabled,
			TTLSeconds:       data.Params.TTLSeconds,
			ConsistencyLevel: data.Params.ConsistencyLevel,
		}

		// Update with values from backend
		params.ConsistencyLevel = types.StringValue(desc.ConsistencyLevel)

		for _, prop := range desc.Properties {
			if prop.Key == "mmap.enabled" {
				v, _ := strconv.ParseBool(prop.Value)
				params.MMAPEnabled = types.BoolValue(v)
			}
			if prop.Key == "collection.ttl.seconds" {
				v, _ := strconv.ParseInt(prop.Value, 10, 64)
				params.TTLSeconds = types.Int64Value(v)
			}
		}

		data.Params = params
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...) // Save state
}

func (r *CollectionResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data CollectionResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...) // Get current state
	if resp.Diagnostics.HasError() {
		return
	}

	connectAddress := data.ConnectAddress.ValueString()
	client, err := r.client.Collection(connectAddress, data.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get cluster client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddress, err.Error()),
		)
		return
	}

	err = client.DropCollection(&zilliz.DropCollectionParams{
		DbName:         data.DbName.ValueString(),
		CollectionName: data.CollectionName.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to drop collection",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s", connectAddress, data.DbName.ValueString(), data.CollectionName.ValueString(), err.Error()),
		)
		return
	}
}

// update logic need to be drop and create.
func (r *CollectionResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var state CollectionResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}
	var plan CollectionResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	connectAddress := plan.ConnectAddress.ValueString()
	client, err := r.client.Collection(connectAddress, plan.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get cluster client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddress, err.Error()),
		)
		return
	}

	// Compare schema and other fields except params
	schemaEqual := reflect.DeepEqual(state.Schema, plan.Schema) &&
		state.DbName.ValueString() == plan.DbName.ValueString() &&
		state.CollectionName.ValueString() == plan.CollectionName.ValueString() &&
		state.ConnectAddress.ValueString() == plan.ConnectAddress.ValueString()

	paramsEqual := reflect.DeepEqual(state.Params, plan.Params)
	params := make(map[string]any)
	if plan.Params != nil {
		if !plan.Params.MMAPEnabled.IsNull() && !plan.Params.MMAPEnabled.IsUnknown() {
			params["mmap.enabled"] = plan.Params.MMAPEnabled.ValueBool()
		}
		if !plan.Params.TTLSeconds.IsNull() && !plan.Params.TTLSeconds.IsUnknown() {
			params["ttlSeconds"] = plan.Params.TTLSeconds.ValueInt64()
		}
		if !plan.Params.ConsistencyLevel.IsNull() && !plan.Params.ConsistencyLevel.IsUnknown() {
			params["consistencyLevel"] = plan.Params.ConsistencyLevel.ValueString()
		}
	}

	if schemaEqual && !paramsEqual {
		// Only params changed, use AlterCollectionProperties
		err := client.AlterCollectionProperties(&zilliz.AlterCollectionPropertiesParams{
			DbName:         plan.DbName.ValueString(),
			CollectionName: plan.CollectionName.ValueString(),
			Properties:     params,
		})
		if err != nil {
			resp.Diagnostics.AddError(
				"Failed to alter collection properties",
				fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s",
					connectAddress, plan.DbName.ValueString(), plan.CollectionName.ValueString(), err.Error()),
			)
			return
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// BuildCollectionID builds the ID for the collection resource.
func BuildCollectionID(connectAddress, dbName, collectionName string) string {
	return fmt.Sprintf("/connections/%s/databases/%s/collections/%s", connectAddress, dbName, collectionName)
}

// ParseCollectionID parses the import ID for a collection resource.
// Format: /connections/{connect_address}/databases/{db_name}/collections/{collection_name}.
func ParseCollectionID(id string) (connectAddress, dbName, collectionName string, ok bool) {
	parts := strings.Split(id, "/")
	if len(parts) != 7 || parts[1] != "connections" || parts[3] != "databases" || parts[5] != "collections" {
		return "", "", "", false
	}
	return parts[2], parts[4], parts[6], true
}

func (r *CollectionResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Parse import ID, format: "/connections/{connect_address}/databases/{db_name}/collections/{collection_name}"
	connectAddress, dbName, collectionName, ok := ParseCollectionID(req.ID)
	if !ok {
		resp.Diagnostics.AddError(
			"Invalid import ID format",
			"Import ID must be in the format '/connections/{connect_address}/databases/{db_name}/collections/{collection_name}'",
		)
		return
	}

	// Set connect_address as 'https://' + connectAddress
	connectAddressFull := "https://" + connectAddress

	client, err := r.client.Collection(connectAddressFull, dbName)
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get collection client (import)",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddressFull, err),
		)
		return
	}

	// Check if collection exists and get its details
	describe, err := client.DescribeCollection(&zilliz.DescribeCollectionParams{
		DbName:         dbName,
		CollectionName: collectionName,
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to import collection: collection does not exist or cannot be retrieved",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s", connectAddressFull, dbName, collectionName, err.Error()),
		)
		return
	}

	// Convert fields for schema
	fields := make([]CollectionSchemaFieldModel, len(describe.Fields))
	for i, field := range describe.Fields {
		fields[i] = convertSchemaFieldModel(field)
	}

	// Create params from backend data for import
	params := &CollectionParamsModel{
		ConsistencyLevel: types.StringValue(describe.ConsistencyLevel),
	}

	for _, prop := range describe.Properties {
		if prop.Key == "mmap.enabled" {
			v, _ := strconv.ParseBool(prop.Value)
			params.MMAPEnabled = types.BoolValue(v)
		}
		if prop.Key == "collection.ttl.seconds" {
			v, _ := strconv.ParseInt(prop.Value, 10, 64)
			params.TTLSeconds = types.Int64Value(v)
		}
	}

	// Set import state with full details from backend
	state := CollectionResourceModel{
		Id:             types.StringValue(req.ID),
		ConnectAddress: types.StringValue(connectAddressFull),
		DbName:         types.StringValue(dbName),
		CollectionName: types.StringValue(collectionName),
		Schema: &CollectionSchemaModel{
			AutoID:              types.BoolValue(describe.AutoID),
			EnabledDynamicField: types.BoolValue(describe.EnableDynamicField),
			Fields:              fields,
		},
		Params: params,
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
