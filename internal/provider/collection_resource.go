package provider

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	zilliz "github.com/zilliztech/terraform-provider-zillizcloud/client"
	"github.com/zilliztech/terraform-provider-zillizcloud/internal/provider/utils"
)

// NewCollectionResource returns a new collection resource.
func NewCollectionResource() resource.Resource {
	return &CollectionResource{}
}

type CollectionResource struct {
	client *zilliz.Client
}

type CollectionResourceModel struct {
	Id             types.String           `tfsdk:"id"` // /connections/{connect_address}/databases/{db_name}/collections/{collection_name}
	ConnectAddress types.String           `tfsdk:"connect_address"`
	DbName         types.String           `tfsdk:"db_name"`
	CollectionName types.String           `tfsdk:"collection_name"`
	Schema         *CollectionSchemaModel `tfsdk:"schema"`
	Params         types.String           `tfsdk:"params"`
}

type CollectionSchemaModel struct {
	AutoID              types.Bool                   `tfsdk:"auto_id"`
	EnabledDynamicField types.Bool                   `tfsdk:"enabled_dynamic_field"`
	Fields              []CollectionSchemaFieldModel `tfsdk:"fields"`
}

type CollectionSchemaFieldModel struct {
	FieldName         types.String            `tfsdk:"field_name"`
	DataType          types.String            `tfsdk:"data_type"`
	IsPrimary         types.Bool              `tfsdk:"is_primary"`
	ElementTypeParams map[string]types.String `tfsdk:"element_type_params"`
}

var _ resource.ResourceWithImportState = &CollectionResource{}

func (r *CollectionResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_collection"
}

func (r *CollectionResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: `Manages a collection in a Zilliz Cloud database.\n\nThe schema block must be defined inline. Changing the schema, db_name, or collection_name will force resource replacement.`,
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The unique identifier for the collection resource, generated by the service.\n\n**Format:**\n` + "`" + `/connections/{db_name}/collections/{collection_name}` + "`" + `\n\n**Fields:**\n- ` + "`db_name`" + ` — The database name.\n- ` + "`collection_name`" + ` — The collection name.\n\n**Example:**\n` + "`" + `/connections/mydb/collections/mycollection` + "`" + `\n\n> **Note:** This value is automatically set and should not be manually specified.`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"connect_address": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `The connection address of the target Zilliz Cloud cluster.\n\nYou can obtain this value from the output of the ` + "`zillizcloud_cluster`" + ` resource, for example:\n` + "`" + `zillizcloud_cluster.example.connect_address` + "`" + `\n\n**Example:**\n` + "`" + `https://in01-295cd02566647b7.aws-us-east-2.vectordb.zillizcloud.com:19534` + "`" + `\n\n> **Note:** The address must include the protocol (e.g., ` + "`https://`" + `).`,
			},
			"db_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `The name of the database containing the collection.`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"collection_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `The name of the collection.`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"params": schema.StringAttribute{
				Optional: true,
				MarkdownDescription: `A JSON-formatted map of advanced params.

**Example:**

` + "`" + `{
  "mmap.enabled": true,
  "ttlSeconds": 86400,
  "consistencyLevel": "Bounded"
}` + "`" + `

> Supports string, integer, and boolean values.`,
				Validators: []validator.String{
					utils.JsonMapValidator(""), // validate the json map
				},
			},
			"schema": schema.SingleNestedAttribute{
				Required: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
				MarkdownDescription: `Defines the schema for the collection. Changing this block will force resource replacement.`,
				Attributes: map[string]schema.Attribute{
					"auto_id": schema.BoolAttribute{
						Optional:            true,
						MarkdownDescription: `Whether to enable automatic ID generation for the collection.`,
					},
					"enabled_dynamic_field": schema.BoolAttribute{
						Optional:            true,
						MarkdownDescription: `Whether to enable dynamic fields for the collection.`,
					},
					"fields": schema.ListNestedAttribute{
						Required:            true,
						MarkdownDescription: `List of field definitions for the collection schema. Each field describes a column in the collection.`,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"field_name": schema.StringAttribute{
									Required:            true,
									MarkdownDescription: `The name of the field.`,
								},
								"data_type": schema.StringAttribute{
									Required:            true,
									MarkdownDescription: `The data type of the field (e.g., "INT64", "FLOAT", "STRING", etc.).`,
								},
								"is_primary": schema.BoolAttribute{
									Optional:            true,
									MarkdownDescription: `Whether this field is the primary key.`,
								},
								"element_type_params": schema.MapAttribute{
									Optional:            true,
									ElementType:         types.StringType,
									MarkdownDescription: `Additional parameters for element type, if applicable (e.g., for array fields).`,
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *CollectionResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*zilliz.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected provider type",
			fmt.Sprintf("Expected *zilliz.Client, got: %T. Please check provider configuration.", req.ProviderData),
		)
		return
	}
	r.client = client
}

func convertSchemaFields(fields []CollectionSchemaFieldModel) []zilliz.CollectionSchemaField {
	result := make([]zilliz.CollectionSchemaField, len(fields))
	for i, f := range fields {
		params := map[string]any{}
		for k, v := range f.ElementTypeParams {
			params[k] = v.ValueString()
		}
		result[i] = zilliz.CollectionSchemaField{
			FieldName:         f.FieldName.ValueString(),
			DataType:          f.DataType.ValueString(),
			IsPrimary:         f.IsPrimary.ValueBool(),
			ElementTypeParams: params,
		}
	}
	return result
}

func (r *CollectionResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data CollectionResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...) // Get planned data
	if resp.Diagnostics.HasError() {
		return
	}

	connectAddress := data.ConnectAddress.ValueString()
	client, err := r.client.Collection(connectAddress, data.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get cluster client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddress, err.Error()),
		)
		return
	}

	err = client.CreateCollection(&zilliz.CreateCollectionParams{
		DbName:         data.DbName.ValueString(),
		CollectionName: data.CollectionName.ValueString(),
		Schema: zilliz.CollectionSchema{
			AutoID:              data.Schema.AutoID.ValueBool(),
			EnabledDynamicField: data.Schema.EnabledDynamicField.ValueBool(),
			Fields:              convertSchemaFields(data.Schema.Fields),
		},
		Params: utils.ParseJsonMap(data.Params, path.Root("params"), &resp.Diagnostics),
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to create database",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, error: %s", connectAddress, data.DbName.ValueString(), err.Error()),
		)
		return
	}

	connectAddress = NormalizeConnectionID(connectAddress)

	data.Id = types.StringValue(BuildCollectionID(connectAddress, data.DbName.ValueString(), data.CollectionName.ValueString()))
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...) // Save state
}

func (r *CollectionResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data CollectionResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...) // Get current state
	if resp.Diagnostics.HasError() {
		return
	}

	connectAddress := data.ConnectAddress.ValueString()
	client, err := r.client.Collection(connectAddress, data.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get cluster client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddress, err.Error()),
		)
		return
	}

	_, err = client.DescribeCollection(&zilliz.DescribeCollectionParams{
		DbName:         data.DbName.ValueString(),
		CollectionName: data.CollectionName.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to describe collection",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s", connectAddress, data.DbName.ValueString(), data.CollectionName.ValueString(), err.Error()),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...) // Save state
}

func (r *CollectionResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data CollectionResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...) // Get current state
	if resp.Diagnostics.HasError() {
		return
	}

	connectAddress := data.ConnectAddress.ValueString()
	client, err := r.client.Collection(connectAddress, data.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get cluster client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddress, err.Error()),
		)
		return
	}

	err = client.DropCollection(&zilliz.DropCollectionParams{
		DbName:         data.DbName.ValueString(),
		CollectionName: data.CollectionName.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to drop collection",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s", connectAddress, data.DbName.ValueString(), data.CollectionName.ValueString(), err.Error()),
		)
		return
	}
}

// update logic need to be drop and create
func (r *CollectionResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var state CollectionResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}
	var plan CollectionResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	connectAddress := plan.ConnectAddress.ValueString()
	client, err := r.client.Collection(connectAddress, plan.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get cluster client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddress, err.Error()),
		)
		return
	}

	// Compare schema and other fields except params
	schemaEqual := reflect.DeepEqual(state.Schema, plan.Schema) &&
		state.DbName.ValueString() == plan.DbName.ValueString() &&
		state.CollectionName.ValueString() == plan.CollectionName.ValueString() &&
		state.ConnectAddress.ValueString() == plan.ConnectAddress.ValueString()

	oldParams := utils.ParseJsonMap(state.Params, path.Root("params"), &resp.Diagnostics)
	newParams := utils.ParseJsonMap(plan.Params, path.Root("params"), &resp.Diagnostics)

	paramsEqual := reflect.DeepEqual(oldParams, newParams)

	if schemaEqual && !paramsEqual {
		// Only params changed, use AlterCollectionProperties
		err := client.AlterCollectionProperties(&zilliz.AlterCollectionPropertiesParams{
			DbName:         plan.DbName.ValueString(),
			CollectionName: plan.CollectionName.ValueString(),
			Properties:     newParams,
		})
		if err != nil {
			resp.Diagnostics.AddError(
				"Failed to alter collection properties",
				fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s",
					connectAddress, plan.DbName.ValueString(), plan.CollectionName.ValueString(), err.Error()),
			)
			return
		}
		resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
		return
	}

	// Otherwise, drop and recreate
	err = client.DropCollection(&zilliz.DropCollectionParams{
		DbName:         plan.DbName.ValueString(),
		CollectionName: plan.CollectionName.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to drop collection",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s",
				connectAddress, plan.DbName.ValueString(), plan.CollectionName.ValueString(), err.Error()),
		)
		return
	}

	err = client.CreateCollection(&zilliz.CreateCollectionParams{
		DbName:         plan.DbName.ValueString(),
		CollectionName: plan.CollectionName.ValueString(),
		Schema: zilliz.CollectionSchema{
			AutoID:              plan.Schema.AutoID.ValueBool(),
			EnabledDynamicField: plan.Schema.EnabledDynamicField.ValueBool(),
			Fields:              convertSchemaFields(plan.Schema.Fields),
		},
		Params: newParams,
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to create collection",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s",
				connectAddress, plan.DbName.ValueString(), plan.CollectionName.ValueString(), err.Error()),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// BuildCollectionID builds the ID for the collection resource.
func BuildCollectionID(connectAddress, dbName, collectionName string) string {
	return fmt.Sprintf("/connections/%s/databases/%s/collections/%s", connectAddress, dbName, collectionName)
}

// ParseCollectionID parses the import ID for a collection resource.
// Format: /connections/{connect_address}/databases/{db_name}/collections/{collection_name}
func ParseCollectionID(id string) (connectAddress, dbName, collectionName string, ok bool) {
	parts := strings.Split(id, "/")
	if len(parts) != 7 || parts[1] != "connections" || parts[3] != "databases" || parts[5] != "collections" {
		return "", "", "", false
	}
	return parts[2], parts[4], parts[6], true
}

func (r *CollectionResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Parse import ID, format: "/connections/{connect_address}/databases/{db_name}/collections/{collection_name}"
	connectAddress, dbName, collectionName, ok := ParseCollectionID(req.ID)
	if !ok {
		resp.Diagnostics.AddError(
			"Invalid import ID format",
			"Import ID must be in the format '/connections/{connect_address}/databases/{db_name}/collections/{collection_name}'",
		)
		return
	}

	// Set connect_address as 'https://' + connectAddress
	connectAddressFull := "https://" + connectAddress

	client, err := r.client.Collection(connectAddressFull, dbName)
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get collection client (import)",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddressFull, err),
		)
		return
	}

	// Check if collection exists and get its details
	describe, err := client.DescribeCollection(&zilliz.DescribeCollectionParams{
		DbName:         dbName,
		CollectionName: collectionName,
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to import collection: collection does not exist or cannot be retrieved",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s", connectAddressFull, dbName, collectionName, err.Error()),
		)
		return
	}

	// Convert collection parameters to JSON string
	paramsStr := "{}"
	if len(describe.Properties) > 0 {
		paramsMap, err := utils.SliceToMap(describe.Properties)
		if err != nil {
			resp.Diagnostics.AddError(
				"Failed to convert collection parameters to map",
				fmt.Sprintf("Error: %s", err.Error()),
			)
		}
		paramsBytes, err := json.Marshal(paramsMap)
		if err != nil {
			resp.Diagnostics.AddError(
				"Failed to marshal collection parameters",
				fmt.Sprintf("Error: %s", err.Error()),
			)
		}
		paramsStr = string(paramsBytes)
	}

	// Set import state (schema is nil, as it cannot be inferred)
	state := CollectionResourceModel{
		Id:             types.StringValue(req.ID),
		ConnectAddress: types.StringValue(connectAddressFull),
		DbName:         types.StringValue(dbName),
		CollectionName: types.StringValue(collectionName),
		Params:         types.StringValue(paramsStr),
		Schema:         nil,
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
