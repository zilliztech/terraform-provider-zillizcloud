// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	zilliz "github.com/zilliztech/terraform-provider-zillizcloud/client"
)

var _ resource.Resource = &ProjectResource{}
var _ resource.ResourceWithConfigure = &ProjectResource{}
var _ resource.ResourceWithImportState = &ProjectResource{}

func NewProjectResource() resource.Resource {
	return &ProjectResource{}
}

type ProjectResource struct {
	client *zilliz.Client
}

type ProjectResourceModel struct {
	Id          types.String `tfsdk:"id"`
	ProjectName types.String `tfsdk:"project_name"`
	Plan        types.String `tfsdk:"plan"`
	OrgType     types.String `tfsdk:"org_type"`
}

func (r *ProjectResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_project"
}

func (r *ProjectResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: `Manages a standard project in Zilliz Cloud.
This resource allows you to create and manage standard projects.
Typical use case: creating projects with specific plan types (e.g., Standard).`,
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The unique identifier for the project, automatically generated by the service.`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"project_name": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				MarkdownDescription: `The name of the project to be created. Must be unique within your account.`,
			},
			"plan": schema.StringAttribute{
				Computed:            true,
				Optional:            true,
				Default:             stringdefault.StaticString("Enterprise"),
				MarkdownDescription: `The plan type for the project (e.g., "Standard", "Enterprise", "Business Critical", "BYOC"). By default, the plan is "Enterprise".`,
			},
			"org_type": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The organization type for the project.`,
			},
		},
	}
}

func (r *ProjectResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*zilliz.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected provider type",
			fmt.Sprintf("Expected *zilliz.Client, got: %T. Please check provider configuration.", req.ProviderData),
		)
		return
	}
	r.client = client
}

func (r *ProjectResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data ProjectResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	projectId, err := r.client.CreateProject(&zilliz.CreateProjectRequest{
		ProjectName: data.ProjectName.ValueString(),
		Plan:        data.Plan.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to create project",
			fmt.Sprintf("ProjectName: %s, Plan: %s, error: %s", data.ProjectName.ValueString(), data.Plan.ValueString(), err.Error()),
		)
		return
	}

	data.Id = types.StringValue(*projectId)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ProjectResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state ProjectResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	project, err := r.client.GetProjectById(state.Id.ValueString())
	if err != nil {
		// If project not found, remove from state (drift detection)
		resp.State.RemoveResource(ctx)
		return
	}

	state.ProjectName = types.StringValue(project.ProjectName)
	state.Plan = types.StringValue(project.Plan)
	state.OrgType = types.StringValue(project.OrgType)

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (r *ProjectResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan ProjectResourceModel
	var state ProjectResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Only plan can be updated (upgraded)
	if !plan.Plan.Equal(state.Plan) {
		_, err := r.client.UpgradeProjectPlan(state.Id.ValueString(), plan.Plan.ValueString())
		if err != nil {
			resp.Diagnostics.AddError(
				"Failed to upgrade project plan",
				fmt.Sprintf("Project ID: %s, New Plan: %s, error: %s", state.Id.ValueString(), plan.Plan.ValueString(), err.Error()),
			)
			return
		}
		state.Plan = plan.Plan
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (r *ProjectResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state ProjectResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Note: The API might not support project deletion
	// For now, we'll just remove it from state
	// TODO: Implement actual deletion if/when API supports it
	resp.Diagnostics.AddWarning(
		"Project deletion not supported by API",
		"The project has been removed from Terraform state, but it still exists in Zilliz Cloud. You may need to delete it manually through the console.",
	)
}

func (r *ProjectResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID is simply the project ID
	projectId := req.ID

	// Fetch the project to verify it exists and get all attributes
	project, err := r.client.GetProjectById(projectId)
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to import project",
			fmt.Sprintf("Project ID: %s, error: %s", projectId, err.Error()),
		)
		return
	}

	// Set all attributes in state
	var state ProjectResourceModel
	state.Id = types.StringValue(projectId)
	state.ProjectName = types.StringValue(project.ProjectName)
	state.Plan = types.StringValue(project.Plan)
	state.OrgType = types.StringValue(project.OrgType)

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
