package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	zilliz "github.com/zilliztech/terraform-provider-zillizcloud/client"
)

var _ resource.Resource = &UserRoleResource{}
var _ resource.ResourceWithConfigure = &UserRoleResource{}
var _ resource.ResourceWithImportState = &UserRoleResource{}

func NewUserRoleResource() resource.Resource {
	return &UserRoleResource{}
}

type UserRoleResource struct {
	client *zilliz.Client
}

type UserRoleResourceModel struct {
	Id             types.String   `tfsdk:"id"` // /connections/{connect_address}/users/{username}/roles
	ConnectAddress types.String   `tfsdk:"connect_address"`
	Username       types.String   `tfsdk:"username"`
	Roles          []types.String `tfsdk:"roles"`
}

func (r *UserRoleResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_user_role"
}

func (r *UserRoleResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: `Manages the roles assigned to a user in a Zilliz Cloud cluster.

This resource allows you to grant or revoke one or more roles for a specific user within a cluster using its connect address.

Typical use case: manage user permissions and access control for database security and multi-tenant environments.`,
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				MarkdownDescription: `The unique identifier for the user-role assignment, generated by the service.

**Format:**  
` + "`" + `/connections/{connect_address}/users/{username}/roles` + "`" + `

- ` + "`connect_address`" + `: The address used to connect to the cluster  
- ` + "`username`" + `: The name of the user

**Example:**  
` + "`" + `/connections/in01-295cd02566647b7.aws-us-east-2.vectordb.zillizcloud.com:19534/users/alias/roles` + "`" + `

> **Note:** This value is automatically set and should not be manually specified.`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"connect_address": schema.StringAttribute{
				Required: true,
				MarkdownDescription: `The connection address of the target Zilliz Cloud cluster.

You can obtain this value from the output of the ` + "`zillizcloud_cluster`" + ` resource, e.g.:  
` + "`" + `zillizcloud_cluster.example.connect_address` + "`" + `

**Example:**  
` + "`" + `https://in01-295cd02566647b7.aws-us-east-2.vectordb.zillizcloud.com:19534` + "`" + `

> **Note:** The address must include the protocol (` + "`https://`" + `).`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"username": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				MarkdownDescription: `The username of the database user to whom the roles will be assigned.

**Constraints:**
- Must be an existing user in the cluster.
- Should follow your organization's naming conventions.`,
			},
			"roles": schema.ListAttribute{
				ElementType: types.StringType,
				Required:    true,
				MarkdownDescription: `A list of roles to assign to the user.

**Example:**  
` + "`" + `["db_admin", "read_only"]` + "`" + `

> **Note:** Only valid roles supported by the cluster can be assigned.`,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

func (r *UserRoleResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*zilliz.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected provider type",
			fmt.Sprintf("Expected *zilliz.Client, got: %T. Please check provider configuration.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// BuildUserRoleID returns the RESTful ID for a user role resource.
func BuildUserRoleID(connectAddress, username string) string {
	return fmt.Sprintf("/connections/%s/users/%s/roles", connectAddress, username)
}

// ParseUserRoleID parses the RESTful ID and returns connectAddress, username, and role.
func ParseUserRoleID(id string) (connectAddress, username string, ok bool) {
	parts := strings.Split(id, "/")
	if len(parts) != 6 || parts[1] != "connections" || parts[3] != "users" || parts[5] != "roles" {
		return "", "", false
	}
	return parts[2], parts[4], true
}

func (r *UserRoleResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data UserRoleResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	connectAddress := data.ConnectAddress.ValueString()
	client, err := r.client.User(connectAddress)
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get user client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddress, err.Error()),
		)
		return
	}

	for _, role := range data.Roles {
		err := client.GrantRoleToUser(&zilliz.UserGrantRoleToUserParams{
			UserName: data.Username.ValueString(),
			RoleName: role.ValueString(),
		})
		if err != nil {
			resp.Diagnostics.AddError(
				"Failed to grant role to user",
				fmt.Sprintf("ConnectAddress: %s, Username: %s, Role: %s, error: %s", data.ConnectAddress.ValueString(), data.Username.ValueString(), role.ValueString(), err.Error()),
			)
			return
		}
	}

	connectAddress = NormalizeConnectionID(connectAddress)

	// Set ID to /connections/{connect_address}/users/{username}/roles
	if len(data.Roles) > 0 {
		data.Id = types.StringValue(BuildUserRoleID(connectAddress, data.Username.ValueString()))
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *UserRoleResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state UserRoleResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	client, err := r.client.User(state.ConnectAddress.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("User Client Error", err.Error())
		return
	}

	roles, err := client.DescribeUser(&zilliz.DescribeUserParams{
		Username: state.Username.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError("List Roles Error", err.Error())
		return
	}

	state.Roles = make([]types.String, 0, len(roles))
	for _, role := range roles {
		state.Roles = append(state.Roles, types.StringValue(role))
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (r *UserRoleResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state UserRoleResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	client, err := r.client.User(state.ConnectAddress.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("User Client Error", err.Error())
		return
	}

	var errors []string
	for _, role := range state.Roles {
		err := client.RevokeRoleFromUser(&zilliz.UserRevokeRoleFromParams{
			UserName: state.Username.ValueString(),
			RoleName: role.ValueString(),
		})
		if err != nil {
			errors = append(errors, fmt.Sprintf("Failed to revoke role '%s': %s", role.ValueString(), err.Error()))
		}
	}

	if len(errors) > 0 {
		resp.Diagnostics.AddError(
			"Failed to revoke some roles",
			fmt.Sprintf("The following errors occurred while revoking roles:\n%s", strings.Join(errors, "\n")),
		)
	}
}

func (r *UserRoleResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state UserRoleResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	connectAddress := NormalizeConnectionID(plan.ConnectAddress.ValueString())

	existingRoles := make(map[string]bool)
	for _, r := range state.Roles {
		existingRoles[r.ValueString()] = true
	}

	plannedRoles := make(map[string]bool)
	for _, r := range plan.Roles {
		plannedRoles[r.ValueString()] = true
	}

	client, err := r.client.User(plan.ConnectAddress.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Failed to get user client", err.Error())
		return
	}

	// Revoke roles not in plan
	for role := range existingRoles {
		if !plannedRoles[role] {
			err := client.RevokeRoleFromUser(&zilliz.UserRevokeRoleFromParams{
				UserName: plan.Username.ValueString(),
				RoleName: role,
			})
			if err != nil {
				resp.Diagnostics.AddError(
					"Failed to revoke role from user",
					fmt.Sprintf("ConnectAddress: %s, Username: %s, Role: %s, error: %s",
						plan.ConnectAddress.ValueString(), plan.Username.ValueString(), role, err.Error()),
				)
				return
			}
		}
	}

	// Grant new roles
	for role := range plannedRoles {
		if !existingRoles[role] {
			err := client.GrantRoleToUser(&zilliz.UserGrantRoleToUserParams{
				UserName: plan.Username.ValueString(),
				RoleName: role,
			})
			if err != nil {
				resp.Diagnostics.AddError(
					"Failed to grant role to user",
					fmt.Sprintf("ConnectAddress: %s, Username: %s, Role: %s, error: %s",
						plan.ConnectAddress.ValueString(), plan.Username.ValueString(), role, err.Error()),
				)
				return
			}
		}
	}

	// Set ID to /connections/{connect_address}/users/{username}/roles
	if len(plan.Roles) > 0 {
		plan.Id = types.StringValue(BuildUserRoleID(connectAddress, plan.Username.ValueString()))
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

func (r *UserRoleResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Parse import ID, format: "/connections/{connect_address}/users/{username}/roles"
	connectAddress, username, ok := ParseUserRoleID(req.ID)
	if !ok {
		resp.Diagnostics.AddError(
			"Invalid import ID format",
			"Import ID must be in the format '/connections/{connect_address}/users/{username}/roles'",
		)
		return
	}

	connectAddress = "https://" + connectAddress

	client, err := r.client.User(connectAddress)
	if err != nil {
		resp.Diagnostics.AddError("Failed to get user client (import)", fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddress, err))
		return
	}

	roles, err := client.DescribeUser(&zilliz.DescribeUserParams{
		Username: username,
	})
	if err != nil {
		resp.Diagnostics.AddError("Import UserRole Error", fmt.Sprintf("Failed to list roles: %s", err.Error()))
		return
	}

	tfsRoles := make([]types.String, 0, len(roles))
	for _, r := range roles {
		tfsRoles = append(tfsRoles, types.StringValue(r))
	}

	state := UserRoleResourceModel{
		Id:             types.StringValue(req.ID),
		ConnectAddress: types.StringValue(connectAddress),
		Username:       types.StringValue(username),
		Roles:          tfsRoles,
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
