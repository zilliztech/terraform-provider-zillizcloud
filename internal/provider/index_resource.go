package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	zilliz "github.com/zilliztech/terraform-provider-zillizcloud/client"
)

// NewIndexResource returns a new collection index resource.
func NewIndexResource() resource.Resource {
	return &IndexResource{}
}

type IndexResource struct {
	client *zilliz.Client
}

type IndexResourceModel struct {
	Id             types.String `tfsdk:"id"`
	ConnectAddress types.String `tfsdk:"connect_address"`
	DbName         types.String `tfsdk:"db_name"`
	CollectionName types.String `tfsdk:"collection_name"`
	FieldName      types.String `tfsdk:"field_name"`
	MetricType     types.String `tfsdk:"metric_type"`
	IndexName      types.String `tfsdk:"index_name"`
	IndexType      types.String `tfsdk:"index_type"`
}

func (r *IndexResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_index"
}

func (r *IndexResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: `Defines an index for a collection field.\n\nThis resource can be attached to or detached from a collection independently.\n\nYou can update or delete the index without affecting the collection resource itself.`,
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The unique identifier for the index resource, generated by the service.\n\n**Format:**\n` + "`" + `/connections/{db_name}/collections/{collection_name}/indexes/{index_name}` + "`" + `\n\n**Fields:**\n- ` + "`db_name`" + ` — The database name.\n- ` + "`collection_name`" + ` — The collection name.\n- ` + "`index_name`" + ` — The index name.\n\n**Example:**\n` + "`" + `/connections/mydb/collections/mycollection/indexes/myindex` + "`" + `\n\n> **Note:** This value is automatically set and should not be manually specified.`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"connect_address": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `The connection address of the target Zilliz Cloud cluster.\n\nYou can obtain this value from the output of the ` + "`zillizcloud_cluster`" + ` resource, for example:\n` + "`" + `zillizcloud_cluster.example.connect_address` + "`" + `\n\n**Example:**\n` + "`" + `https://in01-295cd02566647b7.aws-us-east-2.vectordb.zillizcloud.com:19534` + "`" + `\n\n> **Note:** The address must include the protocol (e.g., ` + "`https://`" + `).`,
			},
			"db_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `Required. The name of the database containing the collection.`,
			},
			"collection_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `Required. The name of the collection to which the index belongs.`,
			},
			"field_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `Required. The name of the field to be indexed.`,
			},
			"metric_type": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: `Optional. The metric type for the index (e.g., "L2", "IP", etc.).`,
			},
			"index_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `Required. The name of the index.`,
			},
			"index_type": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `Required. The type of the index (e.g., "IVF_FLAT", "HNSW", etc.).`,
			},
		},
	}
}

func (r *IndexResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*zilliz.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected provider type",
			fmt.Sprintf("Expected *zilliz.Client, got: %T. Please check provider configuration.", req.ProviderData),
		)
		return
	}
	r.client = client
}

func (r *IndexResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data IndexResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	client, err := r.client.Collection(data.ConnectAddress.ValueString(), data.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get collection client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", data.ConnectAddress.ValueString(), err.Error()),
		)
		return
	}

	params := &zilliz.CreateIndexParams{
		DbName:         data.DbName.ValueString(),
		CollectionName: data.CollectionName.ValueString(),
		IndexParams: []zilliz.IndexParams{
			{
				MetricType:  data.MetricType.ValueString(),
				FieldName:   data.FieldName.ValueString(),
				IndexName:   data.IndexName.ValueString(),
				IndexConfig: map[string]string{"index_type": data.IndexType.ValueString()},
			},
		},
	}
	if err := client.CreateIndex(params); err != nil {
		resp.Diagnostics.AddError(
			"Failed to create index",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s", data.ConnectAddress.ValueString(), data.DbName.ValueString(), data.CollectionName.ValueString(), err.Error()),
		)
		return
	}

	data.Id = types.StringValue(BuildIndexID(NormalizeConnectionID(data.ConnectAddress.ValueString()), data.DbName.ValueString(), data.CollectionName.ValueString(), data.IndexName.ValueString()))
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...) // Save state
}

func (r *IndexResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data IndexResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...) // Get current state
	if resp.Diagnostics.HasError() {
		return
	}

	client, err := r.client.Collection(data.ConnectAddress.ValueString(), data.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get collection client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", data.ConnectAddress.ValueString(), err.Error()),
		)
		return
	}

	_, err = client.DescribeIndex(&zilliz.DescribeIndexParams{
		DbName:         data.DbName.ValueString(),
		CollectionName: data.CollectionName.ValueString(),
		IndexName:      data.IndexName.ValueString(),
	})
	if err != nil {
		// Not found: remove from state
		resp.State.RemoveResource(ctx)
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...) // Keep state
}

func (r *IndexResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data IndexResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...) // Get current state
	if resp.Diagnostics.HasError() {
		return
	}

	client, err := r.client.Collection(data.ConnectAddress.ValueString(), data.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get collection client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", data.ConnectAddress.ValueString(), err.Error()),
		)
		return
	}

	err = client.DropIndex(&zilliz.DropIndexParams{
		DbName:         data.DbName.ValueString(),
		CollectionName: data.CollectionName.ValueString(),
		IndexName:      data.IndexName.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to drop index",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, IndexName: %s, error: %s", data.ConnectAddress.ValueString(), data.DbName.ValueString(), data.CollectionName.ValueString(), data.IndexName.ValueString(), err.Error()),
		)
		return
	}
}

func (r *IndexResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data IndexResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...) // Get planned data
	if resp.Diagnostics.HasError() {
		return
	}

	client, err := r.client.Collection(data.ConnectAddress.ValueString(), data.DbName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get collection client",
			fmt.Sprintf("ConnectAddress: %s, error: %s", data.ConnectAddress.ValueString(), err.Error()),
		)
		return
	}

	// Drop old index
	err = client.DropIndex(&zilliz.DropIndexParams{
		DbName:         data.DbName.ValueString(),
		CollectionName: data.CollectionName.ValueString(),
		IndexName:      data.IndexName.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to drop index (during update)",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, IndexName: %s, error: %s", data.ConnectAddress.ValueString(), data.DbName.ValueString(), data.CollectionName.ValueString(), data.IndexName.ValueString(), err.Error()),
		)
		return
	}

	// Create new index
	params := &zilliz.CreateIndexParams{
		DbName:         data.DbName.ValueString(),
		CollectionName: data.CollectionName.ValueString(),
		IndexParams: []zilliz.IndexParams{
			{
				MetricType:  data.MetricType.ValueString(),
				FieldName:   data.FieldName.ValueString(),
				IndexName:   data.IndexName.ValueString(),
				IndexConfig: map[string]string{"index_type": data.IndexType.ValueString()},
			},
		},
	}
	if err := client.CreateIndex(params); err != nil {
		resp.Diagnostics.AddError(
			"Failed to create index (during update)",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, error: %s", data.ConnectAddress.ValueString(), data.DbName.ValueString(), data.CollectionName.ValueString(), err.Error()),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...) // Save state
}

func (r *IndexResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Parse import ID, format: "/connections/{connect_address}/databases/{db_name}/collections/{collection_name}/indexes/{index_name}"
	connectAddress, dbName, collectionName, indexName, ok := ParseIndexID(req.ID)
	if !ok {
		resp.Diagnostics.AddError(
			"Invalid import ID format",
			"Import ID must be in the format '/connections/{connect_address}/databases/{db_name}/collections/{collection_name}/indexes/{index_name}'",
		)
		return
	}

	connectAddressFull := "https://" + connectAddress
	client, err := r.client.Collection(connectAddressFull, dbName)
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get collection client (import)",
			fmt.Sprintf("ConnectAddress: %s, error: %s", connectAddressFull, err),
		)
		return
	}

	_, err = client.DescribeIndex(&zilliz.DescribeIndexParams{
		DbName:         dbName,
		CollectionName: collectionName,
		IndexName:      indexName,
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to import index: index does not exist or cannot be retrieved",
			fmt.Sprintf("ConnectAddress: %s, DbName: %s, CollectionName: %s, IndexName: %s, error: %s", connectAddressFull, dbName, collectionName, indexName, err.Error()),
		)
		return
	}

	state := IndexResourceModel{
		Id:             types.StringValue(req.ID),
		ConnectAddress: types.StringValue(connectAddressFull),
		DbName:         types.StringValue(dbName),
		CollectionName: types.StringValue(collectionName),
		FieldName:      types.StringValue(""), // Not available from import
		MetricType:     types.StringValue(""), // Not available from import
		IndexName:      types.StringValue(indexName),
		IndexType:      types.StringValue(""), // Not available from import
	}
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func BuildIndexID(connectAddress, dbName, collectionName, indexName string) string {
	return fmt.Sprintf("/connections/%s/databases/%s/collections/%s/indexes/%s", connectAddress, dbName, collectionName, indexName)
}

// ParseIndexID parses the import ID for an index resource.
// Format: /connections/{connect_address}/databases/{db_name}/collections/{collection_name}/indexes/{index_name}.
func ParseIndexID(id string) (connectAddress, dbName, collectionName, indexName string, ok bool) {
	parts := strings.Split(id, "/")
	if len(parts) != 9 || parts[1] != "connections" || parts[3] != "databases" || parts[5] != "collections" || parts[7] != "indexes" {
		return "", "", "", "", false
	}
	return parts[2], parts[4], parts[6], parts[8], true
}
